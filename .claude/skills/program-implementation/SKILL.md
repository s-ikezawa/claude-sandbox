---
name: program-implementation
description: あらゆるプログラム実装タスク(新規機能開発、クラス/関数作成、Value Object実装、API実装、バグ修正、リファクタリング等)で必ず最初に起動する。このスキルはTDD、SOLID、DRY、KISS、YAGNIの原則に従った高品質な実装を保証する。コードを書く前に必ずこのスキルを起動すること。
---

## 用語について

このドキュメントで使用される用語の定義については、[用語集](resources/glossary.md)を参照してください。

特に重要な用語:
- **段階**: TDDサイクルの各フェーズ（Red段階、Green段階、Refactor段階）
- **本質的な重複**: 同じビジネスルールの表現
- **偶然の重複**: たまたまコードが似ているだけの重複

---

## 実装の基本方針

プログラム実装時は以下の原則を**この順序で**適用すること:

### 0. テスティングフレームワークの選定
実装開始前に[テスティングフレームワークの選定ガイド](resources/testing-frameworks.md)を確認し、適切なフレームワークを選択する。

- **プロジェクト固有の指定を最優先**: CLAUDE.md、README.md、既存の設定ファイルを確認
- **指定がない場合**: 言語別のデフォルトフレームワークを使用（TypeScript/JavaScript: Vitest/Jest、Python: pytest、など）

### 1. テスト駆動開発(TDD)でコードを書く
[テスト駆動開発の原則](resources/test-driven-development.md)に則り、Red-Green-Refactorサイクルで実装する。

#### テストカバレッジ目標
実装完了時には以下のカバレッジ目標を達成すること：

- **ビジネスロジック**: 90-100%のカバレッジを目指す
  - Value Object、Entity、Service層などのドメインロジック
  - バリデーション、計算ロジック、状態遷移など
- **インフラ層・UI層**: 70-80%を目安とする
  - データベースアクセス、外部API連携、コンポーネントなど

**カバレッジ確認タイミング**:
1. Green段階完了時: 基本的なテストケースでカバレッジを確認
2. Refactor段階完了時: 全ての分岐・エッジケースを含めて最終確認
3. 目標未達の場合: 不足しているテストケースを追加（Red段階に戻る）

#### Red段階で適用する原則
- **TDD**: 失敗するテストを書く
- **[YAGNI原則](resources/yagni.md)**: 今必要なテストのみ書く
- **[KISS原則](resources/kiss.md)**: 最もシンプルなテストを書く
- **網羅性**: 正常系・異常系・境界値・エッジケースを考慮したテストを書く

#### Green段階で適用する原則
- **TDD**: テストを通す最小限のコードを書く
- **[YAGNI原則](resources/yagni.md)**: テストが要求するもののみ実装
- **[KISS原則](resources/kiss.md)**: 最もシンプルな実装でテストを通す

**Green段階で許容されるもの**:
- コードの重複（2〜3回程度）
- 長い関数、深いネスト、メソッドチェーン
- ハードコーディング、マジックナンバー
- 単一クラスに複数責務、曖昧な変数名

**Green段階でも避けるべきもの**:
- 次のテストケースで確実に壊れる設計
- セキュリティ上の問題
- テストが偶然通っているだけの間違ったロジック

詳細は[テスト駆動開発の原則](resources/test-driven-development.md)の「Green段階で許容されるもの」を参照。

#### Refactor段階で適用する原則
- **[DRY原則](resources/dont-repeat-yourself.md)**: 重複を除去し、共通化する
- **[SOLID原則](resources/solid.md)**: 責務を分離し、設計を改善する
- **[KISS原則](resources/kiss.md)**: シンプルさを保つ（過度な抽象化を避ける）
- **[デメテルの法則](resources/law-of-demeter.md)**: メソッドチェーンを避け、カプセル化を保つ
- **[コンポジション優先原則](resources/composition-over-inheritance.md)**: 継承よりもコンポジションを検討

### 2. 全段階で意識する原則

#### KISS原則（Keep It Simple, Stupid）
[KISS原則](resources/kiss.md)は全ての段階で意識する。

- シンプルさを最優先
- 不必要な複雑さを導入しない
- より単純な解決策がないか常に考える

#### YAGNI原則（You Aren't Gonna Need It）
[YAGNI原則](resources/yagni.md)は全ての段階で意識する。

- 今必要でない機能は実装しない
- 将来の予測に基づいた実装を避ける
- 使われていないコードは削除する

### 3. 原則適用の優先順位

複数の原則が競合する場合は、以下の優先順位で判断する:

1. **YAGNI** > DRY: 現時点で使われていないコードを先回りして共通化する意味はない
2. **KISS** > SOLID: シンプルさを保つため、過度な抽象化は避ける
3. **DRY** ⇄ KISS: バランスを取る（詳細は[DRY vs KISS 判断ガイド](resources/dry-vs-kiss-decision-guide.md)を参照）

#### DRY vs KISS の判断基準（概要）

- **重複が2回以下** → KISS優先（共通化しない）
  - **例外**: ビジネスロジック（税率、パスワード最小文字数など）は2回でも共通化
- **重複が3回以上** → 以下を判断（詳細は[判断ガイド](resources/dry-vs-kiss-decision-guide.md)参照）
  - **本質的な重複**（同じビジネスルールや知識の表現） → DRY優先（共通化する）
  - **偶然の重複**（コードは似ているが意味が異なる） → KISS優先（共通化しない）
  - **共通化で複雑になる場合** → KISS優先（共通化しない）

**本質的な重複と偶然の重複の見分け方**:
- 本質的な重複: 同じビジネスルール（例: 消費税率10%、パスワード最小文字数）
- 偶然の重複: たまたまコードが似ているだけ（例: 注文合計額と在庫評価額の計算式）

**原則**: 迷ったらKISS優先。共通化は必要になってから行う（YAGNI）。

## 迷った時の判断基準

1. **テストはあるか?** → あればリファクタリングは後でも安全
2. **変更の影響範囲は?** → 広ければ慎重に設計する
3. **チームの合意は?** → 独断で過度な抽象化をしない
4. **3回ルールに該当するか?** → 重複が3回未満なら共通化を待つ
