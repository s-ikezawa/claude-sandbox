# 実行フェーズ詳細

このドキュメントでは、Git Commit Message Creatorスキルの3つの実行フェーズの詳細な手順を説明します。

**用語の定義**: このドキュメントでは、以下の用語を使用します。詳細は [SKILL.md](../SKILL.md) を参照してください。
- **開発者**: このスキルを使用してコミットメッセージを生成する人（AIが対話する相手）
- **ユーザー**: ソフトウェアのエンドユーザー（開発者が作成するアプリケーションを使用する人）

## フェーズ1：情報収集

### 1. 変更内容の取得

**実装方法**: 以下のコマンドを1つのメッセージ内で並列実行する（推奨）：

- `git status`: 変更されたファイルとステージング状態を確認
- `git diff`: ステージングされていない変更内容を取得
- `git diff --staged`: ステージング済みの変更を確認（常に実行。出力が空でも問題ない）
- `git log --oneline -10`: 最近の10件のコミット履歴を取得（スタイル把握用）
  - **成功した場合**: 最近のコミットメッセージのスタイルを確認し、プロジェクトの慣習に従う
  - **失敗した場合**: 初回コミットと判断（下記の判断基準を参照）

効率を優先する場合、全コマンドを同時実行する。

**初回コミットの判断**:
上記の`git log`コマンドが以下のいずれかの状態になった場合、初回コミットと判断する：
- コマンドの出力が空の場合
- "fatal: your current branch 'main' does not have any commits yet"または類似のエラーメッセージ
- "fatal: bad default revision 'HEAD'"というエラーメッセージ
- コミット履歴に関連するその他のエラー（"does not have any commits", "bad revision"等）

**重要**: 権限エラー、リポジトリ破損、ネットワークエラー等、コミット履歴以外の理由でエラーが発生した場合は、開発者に報告して処理を中断する。これらは初回コミットとは無関係のエラーである。

**注意**:
- 初回コミットの扱いについては [edge-cases.md - 初回コミット](edge-cases.md#初回コミット) を参照
- 変更がない場合の対応は [edge-cases.md - 変更がない場合](edge-cases.md#変更がない場合) を参照

### 2. 変更の分析

変更内容を以下の観点で分析する：
- **追加されたコード**: 新機能か、既存機能の拡張か
- **削除されたコード**: 不要なコードの削除か、機能の削除か
- **修正されたコード**: バグ修正か、リファクタリングか、パフォーマンス改善か
- **ドキュメントの変更**: コメント、README、ドキュメントファイルなど
- **テストの変更**: 新規テスト追加か、既存テスト修正か
- **設定ファイルの変更**: ビルド設定、CI設定、依存関係など
- **複数の変更タイプが混在**: 1つにまとめるか分割するかの判断は「**フェーズ3 → 複数の変更を含む場合の処理**」を参照

### 3. セキュリティチェック（ファイル名ベースの簡易チェック）

**目的**: 明らかに問題のあるファイルを早期に検出する

**チェック対象**: `git status`の出力から以下のファイル名パターンを検出：
- 認証情報ファイル: `.env`, `credentials.json`, `secrets.yaml`, `config/secrets.*`
- 秘密鍵: `*.pem`, `*.key`, `id_rsa`, `*.p12`, `*.pfx`
- データベース認証情報: `database.yml`, `db_config.*`

**検出時の対応**:
- 開発者に警告し、コミットを推奨しない
- `.gitignore`への追加を提案する（適切な場合）
- 詳細な対応フローは [edge-cases.md - セキュリティ上問題のあるファイルが検出された場合](edge-cases.md#セキュリティ上問題のあるファイルが検出された場合) を参照

**注意**: これは簡易チェックです。フェーズ3でファイル内容の詳細チェック（トークンパターン検出等）を必ず実施してください。

## フェーズ2：メッセージ作成

### 4. コミットタイプ(type)の決定

変更内容に基づいて適切なタイプを決定する。

**主要なタイプ（概要）**：
- **feat**: 新機能の追加
- **fix**: バグ修正
- **docs**: ドキュメントのみの変更
- **style**: コードの意味に影響しない変更（フォーマット等）
- **refactor**: バグ修正や機能追加を伴わないコード改善
- **perf**: パフォーマンス改善
- **test**: テストの追加や修正
- **build**: ビルドシステムや外部依存関係の変更
- **ci**: CI設定の変更
- **chore**: その他の変更（依存関係更新等）

**判断の流れ**：
1. WIPコミットが必要か確認 → [edge-cases.md - WIP](edge-cases.md#wip-work-in-progress--作業中コミット) を参照
2. 変更の種類を判断（上記の主要タイプから選択）
3. 各タイプの詳細な説明と使用例は [conventional-commits-spec.md - よく使われるタイプ](conventional-commits-spec.md#よく使われるタイプ) を参照
4. 複数のタイプに該当する場合や判断に迷う場合は [type-selection-guide.md](type-selection-guide.md) を参照
5. 破壊的変更がある場合の`!`記号の使い方は「**フェーズ3 → フッターの追加と破壊的変更の表示**」を参照

### 5. スコープ(scope)の決定（オプション）

スコープは変更の影響範囲を示す。以下の手順で決定する：

**判断フロー**:
1. 既存の慣習を確認（git logから過去のスコープ形式を確認） → あれば踏襲
2. 既存の慣習がない → プロジェクトのエコシステムを判断
3. 複数言語の場合 → 変更対象ファイルの言語を優先
4. 迷った場合 → ケバブケースを使用

#### スコープの特定方法
- ファイルパスやディレクトリ構造から影響範囲を特定する
- モジュール名、コンポーネント名、機能名などを使用する
- 変更が広範囲に及ぶ場合はスコープを省略してもよい

#### 命名規則
1. **既存の慣習がある場合**: フェーズ1で実行した`git log`の結果から、過去のコミットで使用されているスコープの形式（ケバブケース、スネークケース、キャメルケース等）を確認し、それを踏襲する（最優先）
2. **既存の慣習がない場合**（初回コミット等）: 以下の基準で決定
   - **単一単語の場合**: そのまま使用（`api`, `parser`, `ui`, `auth`, `database`）
   - **複数単語の場合**: プロジェクトのエコシステムを判定してから命名規則を選択

#### プロジェクトのエコシステム判断方法

**確認手順**：
1. Globツールを使用して、現在のディレクトリで以下のファイルパターンの存在を確認する
   （例: `package.json`, `tsconfig.json`, `requirements.txt` 等）
2. 複数のエコシステムが検出された場合は、以下の「複数言語/フレームワークが混在する場合」を参照
3. 判断した言語/フレームワークに応じて命名規則を選択

**Globコマンド例**：
```bash
# JavaScript/TypeScript
glob "package.json"
glob "tsconfig.json"

# Python
glob "requirements.txt"
glob "setup.py"

# Ruby
glob "Gemfile"

# Java
glob "pom.xml"
glob "build.gradle"

# Go
glob "go.mod"
```

以下のファイルの存在から主要な言語/フレームワークを判断する：

- **JavaScript/TypeScript**: `package.json`, `tsconfig.json`, `yarn.lock`, `pnpm-lock.yaml`
- **Python**: `requirements.txt`, `setup.py`, `pyproject.toml`, `Pipfile`
- **Ruby**: `Gemfile`, `Rakefile`
- **Java**: `pom.xml`, `build.gradle`, `build.gradle.kts`
- **C#/.NET**: `*.csproj`, `*.sln`, `packages.config`
- **Go**: `go.mod`, `go.sum`
- **Rust**: `Cargo.toml`, `Cargo.lock`
- **PHP**: `composer.json`, `composer.lock`

判断後、以下の命名規則を適用：
- **JavaScript/TypeScript**: ケバブケース推奨（`user-service`, `api-client`）
- **Python/Ruby**: スネークケースも一般的（`user_service`, `api_client`）
- **Java/C#**: キャメルケースも使用される（`userService`, `apiClient`）
- **Go/Rust**: ケバブケースが一般的（`user-service`, `api-client`）
- **迷った場合**: ケバブケースを推奨（言語横断的に使用可能）

#### 複数言語/フレームワークが混在する場合
プロジェクトに複数の言語やフレームワークが含まれる場合、以下の優先順位で命名規則を決定する：

1. **変更対象ファイルの言語を優先**: 変更されたファイルが属する言語/フレームワークの慣習に従う
   - 例：Pythonファイルを変更した場合、スネークケース（`user_service`）を使用
   - 例：TypeScriptファイルを変更した場合、ケバブケース（`user-service`）を使用
2. **プロジェクトの主要言語を優先**: 変更が複数の言語にまたがる場合、最も多くのファイルが属する言語の慣習を使用
   - プロジェクトのファイル数やディレクトリ構造から主要言語を判定
3. **迷った場合**: ケバブケースを推奨（言語横断的に使用可能で、最も広く受け入れられている）

**例**：
- フロントエンド（TypeScript）とバックエンド（Python）が混在するプロジェクトで、Pythonファイルのみを変更した場合 → スネークケース（`api_client`）
- フロントエンドとバックエンドの両方を変更した場合 → プロジェクトの主要言語の慣習、または既存のコミットメッセージのスコープ形式を確認して決定

#### スコープの粒度
- **単数形を推奨**: `user` が推奨（ただしプロジェクトの慣習に従う）
- **適切な粒度**: 具体的すぎず、抽象的すぎない（例：`user-auth` は適切、`user-auth-login-form-validation` は具体的すぎる）

#### スコープの例
```text
✅ 良い例:
feat(api): 新しいエンドポイントを追加
fix(user-service): ユーザー検証ロジックを修正  # JavaScript/TypeScript
fix(user_service): ユーザー検証ロジックを修正  # Python/Ruby
refactor(userService): トークン処理を改善  # Java/C#

❌ 避けるべき例:
refactor(auth-provider-service-layer): ...  # 具体的すぎる
feat(User-Service): ...  # パスカルケースは一般的でない
fix(user service): ...  # スペースは使用不可
```

### 6. 説明文(description)の作成

#### 基本ルール
- 変更内容を簡潔に要約する（日本語で30-40文字以内を推奨）
- **日本語で記述する**（ただし、技術用語・パッケージ名・コマンド名は英語のまま使用）
- **文末に句点（。）を付けない** - Conventional Commitsの標準慣習（説明文は命令形または動詞句として扱われる）
  - **例外**: フェーズ1で`git log`を確認し、既存のコミットメッセージが句点を使用している場合はプロジェクトの慣習に従う
- 「〜を追加」「〜を修正」のような動詞句、または「ユーザー認証機能を追加」のような名詞+動詞の形式で記述する

#### 記述例

```text
✅ 良い例:
feat(api): ユーザー情報取得APIを追加
fix(parser): JSON解析時のnullエラーを修正
docs: READMEのインストール手順を更新
perf(query): データベースクエリのインデックスを最適化

❌ 悪い例:
feat(api): ユーザー情報取得APIを追加。 # 文末に句点不要
fix(parser): json解析時のnullエラーを修正 # 技術用語は英語推奨（JSON）
```

### 7. 本文(body)の必要性判断と作成

#### 本文を追加すべき場合
以下の場合は本文を追加する：
- 変更の理由や背景を説明する必要がある
- 複数の変更が含まれる（ただし関連性がある場合のみ。無関係な変更は複数コミットに分割すべき）
- 実装の詳細を記録したい
- 関連するissueやPRを参照したい

#### 本文の記述形式
- **説明文の1行下**（空行を1行挟む）から記述する
- 自由形式で、段落や箇条書きを使用できる
- **日本語で記述する**（技術用語、コマンド、コード例は英語のままでOK）
- **文末の句点**: 本文では通常の文章として句点（。）を使用する

#### 記述例
```text
✅ 良い例:
feat(auth): OAuth 2.0認証を実装

Google OAuth 2.0を使用した認証機能を追加した。
ユーザーはGoogleアカウントでログインできるようになる。

実装内容：
- oauth2clientライブラリを使用
- アクセストークンはRedisに保存
- トークンの有効期限は24時間

Refs: #123
```

## フェーズ3：最終調整と提示

### 8. フッター(footer)の追加と破壊的変更の表示

#### 一般的なフッター
以下の場合はフッターを追加する：
- **破壊的変更がある**: `BREAKING CHANGE: 説明`（詳細は下記参照）
- **issueを参照する**: `Refs: #123`（情報参照のみ、issueはクローズされない）
- **issueをクローズする**: 以下のいずれかを使用（コミットがマージされた際にissueが自動的にクローズされる）
  - `Fixes: #123` - バグ修正のissueをクローズする場合（推奨）
  - `Closes: #123` - 機能実装やタスクのissueをクローズする場合
  - `Resolves: #123` - 問題解決全般（Closesと同義）
- **レビュアーを記載する**: `Reviewed-by: 名前`
- **共同作業者を記載する**: `Co-authored-by: 名前 <email@example.com>`

#### フッターの言語規則
- **BREAKING CHANGE**: 常に大文字の英語 `BREAKING CHANGE:` を使用する（仕様で定められている）
- **標準トークン**: `Refs`, `Closes`, `Reviewed-by` などは英語のまま使用（国際的な互換性のため推奨）
- **説明文**: トークンの後に続く説明文は日本語で記述してよい（例：`BREAKING CHANGE: APIのレスポンス形式を変更した`）
- **句点の扱い**:
  - フッターの説明文（複数の文や詳細な記述）では句点（。）を使用する（本文と同様の扱い）
  - トークンのみの行（`Refs: #123`, `Closes: #456` 等）には句点は不要

#### 破壊的変更(Breaking Changes)の判断基準と表示方法

**破壊的変更とは**: 既存のコードやAPIの互換性を損なう変更を指す。

**破壊的変更の判断基準**:
以下の変更は破壊的変更と見なす：
- 公開APIのシグネチャ変更（引数の追加・削除・変更、戻り値の型変更）
- 設定ファイルの形式変更（既存の設定が無効になる変更）
- データベーススキーマの互換性のない変更（マイグレーションが必須となる変更）
- 環境変数の削除や名前変更（既存の環境変数が使えなくなる）
- サポートするランタイムバージョンの変更（例: Node.js 12 → 14以上が必須）
- 既存の動作の変更（デフォルト値の変更、エラーハンドリングの変更等）

以下は破壊的変更と見なさない：
- 内部実装の変更（公開APIは維持されている）
- 新機能の追加（既存機能は維持されている）
- バグ修正（元々意図された動作に戻す変更）
- パフォーマンス改善（動作は変わらない）
- 非推奨の警告追加（機能自体は削除していない）

**表示方法**: 2つの方法がある：
1. **`!` の使用**: タイプとスコープの直後、コロン(`:`)の直前に`!`を付ける
2. **`BREAKING CHANGE:` フッターの使用**: フッターセクションに詳細を記載

**使い分けの基準**：
- **簡潔な変更の場合**: `!` のみを使用
  ```text
  feat!: APIレスポンス形式を変更
  ```
- **詳細な説明が必要な場合**: `!` と `BREAKING CHANGE:` フッターを併用（推奨）
  ```text
  feat(api)!: レスポンス形式を変更

  BREAKING CHANGE: APIのレスポンス形式をRESTからGraphQLに変更した。
  既存のクライアントは新しいGraphQLクエリ形式に更新する必要がある。
  ```
- **複数の破壊的変更がある場合**: フッターに詳細をリスト形式で記載
- **マイグレーション手順が必要な場合**: フッターに手順を箇条書きで記載

### 9. 複数の変更を含む場合の処理

**要約**: 独立した変更は複数のコミットに分割し、関連性がある変更は1つにまとめる。判断に迷う場合は必ず開発者に確認する。

変更内容の分析（フェーズ1-4）で複数の異なるタイプの変更が検出された場合：

#### 判断の基準
1. **関連性がある変更**: 1つのコミットにまとめてもよい（主要な変更タイプを使用）
   - 例：新機能追加とそれに関するドキュメント更新 → `feat`
   - 例：バグ修正とそれに関するテスト追加 → `fix`

2. **独立した変更**: 複数のコミットに分割すべき
   - 例：バグ修正 + 無関係な新機能 → 2つのコミットに分割
   - 例：バグ修正 + テスト追加 + ドキュメント更新（すべて無関係） → 3つのコミットに分割

#### 関連性の判断基準

以下の条件をすべて満たす場合、変更は「関連している」と判断する：
1. **同じ機能・バグに関連**: 同じissue番号、同じ機能名、同じバグ修正
2. **依存関係がある**: 一方の変更がもう一方を前提としている
3. **時間的近接性**: 同じ作業セッションで行われた変更

以下の場合は「独立している」と判断し、分割を推奨：
1. **異なる機能**: 機能Aと機能Bのように、無関係な複数の機能
2. **異なるバグ**: バグ1とバグ2のように、無関係な複数のバグ修正
3. **異なるタイプで関連性がない**: バグ修正 + 無関係なドキュメント更新

#### 関連性の具体例

**✅ 関連している（1つのコミットにまとめる）**：
- **バグ修正 + そのバグを検出するテスト追加**
  - 例：`src/parser.ts`のnullエラー修正 + `tests/parser.test.ts`に該当テストケース追加
  - 理由：テストはバグ修正の一部であり、同じissueに紐づく
- **新機能実装 + その機能のドキュメント更新**
  - 例：OAuth認証機能の実装 + `README.md`に認証設定手順を追加
  - 理由：ドキュメントは新機能の説明であり、機能と一体
- **リファクタリング + それに伴う型定義の更新**
  - 例：関数の引数を変更 + TypeScriptの型定義を更新
  - 理由：型定義はリファクタリングの必然的な結果
- **API変更 + それを使用するクライアントコードの修正**
  - 例：APIエンドポイントのパス変更 + フロントエンドの呼び出し元を更新
  - 理由：依存関係があり、一方だけでは動作しない

**❌ 独立している（複数コミットに分割）**：
- **ログイン機能のバグ修正 + 検索機能の新規追加**
  - 理由：異なる機能領域で、依存関係がない
  - 分割：`fix(auth): ログイン時のセッションエラーを修正` と `feat(search): 全文検索機能を追加`
- **API仕様の変更 + 無関係なREADMEのタイポ修正**
  - 理由：関連性がなく、異なるissueまたは作業タスク
  - 分割：`feat(api)!: レスポンス形式を変更` と `docs: READMEのタイポを修正`
- **依存パッケージの更新 + 新機能の実装**
  - 理由：異なる目的で、依存関係がない（パッケージ更新は保守作業、新機能は開発作業）
  - 分割：`chore(deps): lodashを更新` と `feat(notification): プッシュ通知機能を追加`
- **複数の無関係なバグ修正**
  - 例：パーサーのバグ + ログ出力のバグ + UI表示のバグ
  - 理由：それぞれ独立したバグで、異なるissue番号
  - 分割：各バグごとに個別のコミット

#### 複数コミット分割時の処理フロー

複数のコミットに分割すると判断した場合、以下のフローに従う：

1. **開発者に確認する**:
   AskUserQuestionツールを使用して、以下の選択肢を提示する：

   ```text
   変更内容を分析した結果、以下の独立した変更が検出されました：
   1. [タイプ] [説明]
   2. [タイプ] [説明]
   3. [タイプ] [説明]

   これらを個別のコミットに分割することを推奨します。
   ```

   **実装方法**: AskUserQuestionツールで以下の選択肢を提示：
   - 「分割する」: 各変更ごとに個別のコミットを作成
   - 「1つにまとめる」: すべての変更を1つのコミットにまとめる

2. **開発者の回答に応じて処理**:
   - **「はい」/ 分割を承認**: 各変更ごとに個別のコミットメッセージを生成し、順番に提示
   - **「いいえ」/ 1つにまとめる**:
     1. 最も影響の大きい変更タイプを優先して選択（例：`fix` → `feat` → `refactor` → `docs` → `test`）
     2. 他の変更は本文で箇条書きで説明
     3. 例：主要変更が`fix`で、テストとドキュメントも含む場合
        ```text
        fix(auth): ログイン時のセッションエラーを修正

        セッション管理のバグを修正した。
        また、以下の変更も含む：
        - エッジケースのテストケースを追加
        - 認証フローのドキュメントを更新
        ```
   - **開発者が「すぐに実行して」などと指示**: 確認後、順番に `git add` と `git commit` を実行

3. **実行時の注意**:
   - 各コミットで適切なファイルのみを `git add` する
   - コミット順序（推奨）：優先度の高い変更から（例：`fix` → `feat` → `docs` → `test` → `chore`）
   - 各コミット後に `git status` で確認

#### 分割例
完全な分割プロセスの例は [examples.md - 例3：複数の変更タイプを含む場合](examples.md#例3複数の変更タイプを含む場合) を参照

### 10. メッセージの生成と提示

#### 提示形式
- 作成したコミットメッセージを明確に提示する（コードブロックを使用）
- 複数の候補がある場合は、推奨順に提示する
- メッセージの各部分（タイプ、スコープ、説明文、本文、フッター）の選択理由を簡潔に説明する

#### コミット実行の手順

**注意**: コミットの実行には複数行メッセージを正しく扱うためのHEREDOC構文を使用する。詳細は下記の「HEREDOCを使用したコミット実行方法」を参照。

##### コミット実行前の確認

**セキュリティチェック（ファイル内容の詳細チェック）**：

**目的**: ファイル内容に含まれる機密情報を検出する（フェーズ1のファイル名チェックとは別）

**検出方法**:
1. Bashツールで`git diff --staged`を実行し、ステージング済みの変更内容を取得
2. Readツールを使用して、変更されたファイルの内容を確認（必要に応じて）
3. Grepツールを使用して、以下のパターンを検索:
   - **キー名パターン**: `password=|token=|api_key=|secret=|apiKey:|SECRET_KEY|AWS_ACCESS_KEY_ID`
   - **トークンプレフィックス**: `sk-|ghp_|gho_|xoxb-|ya29\.`
   - **プライベートキー**: `-----BEGIN.*PRIVATE KEY-----`
   - **GCP認証情報**: `"type": "service_account"`
4. 視覚的に以下を確認:
   - `AKIA`で始まる20文字の英数字（AWS Access Key ID）
   - 連続する64文字以上のBase64文字列（認証情報のキー名の後に続く場合）

**Grepコマンド例**：
```bash
# キー名パターンの検出
grep "password=|token=|api_key=|secret=|apiKey:|SECRET_KEY|AWS_ACCESS_KEY_ID" --output_mode content -i

# トークンプレフィックスの検出
grep "sk-|ghp_|gho_|xoxb-|ya29\." --output_mode content

# プライベートキーの検出
grep "-----BEGIN.*PRIVATE KEY-----" --output_mode content

# GCP認証情報の検出
grep "\"type\": \"service_account\"" --output_mode content
```

**検出対象パターン**：
- **キー名パターン**: `password=`, `token=`, `api_key=`, `secret=`, `apiKey:`, `SECRET_KEY`, `AWS_ACCESS_KEY_ID` 等
- **トークンプレフィックス**: `sk-` (OpenAI), `ghp_` (GitHub Personal Access Token), `gho_` (GitHub OAuth Token), `xoxb-` (Slack), `ya29.` (Google OAuth) 等
- **Base64エンコード**: 連続する64文字以上のBase64文字列（特に認証情報のキー名の後に続く場合）
- **AWS認証情報**: `AKIA` で始まる20文字の英数字（Access Key ID）、40文字の英数字（Secret Access Key）
- **Azure認証情報**: `[0-9a-zA-Z/+=]{88}` (Shared Access Key)
- **GCP認証情報**: `"type": "service_account"`を含むJSON構造
- **JWTトークン**: `eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+` (Authorization ヘッダーやトークンフィールドに含まれる場合)
- **プライベートキー**: `-----BEGIN PRIVATE KEY-----`, `-----BEGIN RSA PRIVATE KEY-----` 等

**検出時の対応**: [edge-cases.md - セキュリティ上問題のあるファイルが検出された場合](edge-cases.md#セキュリティ上問題のあるファイルが検出された場合) の対応手順に従う

---
- **開発者の明示的な確認を得てからコミットを実行する**
- 開発者が「コミットして」「実行して」などと明示的に指示した場合のみ、`git commit` を実行
- 実行時は HEREDOC を使用してコミットメッセージを渡す（複数行メッセージの場合）

##### HEREDOCを使用したコミット実行方法

**HEREDOCについて**:
- `<<'EOF'` のシングルクォートは**変数展開を防ぐ**ために使用する
  （ドル記号`$`、バッククォート、バックスラッシュ`\`などを文字列としてそのまま扱う）
- シングルクォートなし（`<<EOF`）の場合、メッセージ内の変数が展開されてしまう可能性がある
- 複数行のコミットメッセージを正しくフォーマットするために必須

**シングルクォートの重要性**：
- **`<<'EOF'` の場合**：変数展開なし（推奨）
  - メッセージに`$var`と書いても文字列として扱われる
- **`<<EOF` の場合**：変数展開あり（非推奨）
  - メッセージに`$var`と書くと変数の値に置換される

**比較例**：
```bash
# 良い例（'EOF'でクォート）
git commit -m "$(cat <<'EOF'
perf: コスト削減により$500/月の削減を達成
EOF
)"
# 出力：「perf: コスト削減により$500/月の削減を達成」

# 悪い例（EOFのみ）
git commit -m "$(cat <<EOF
perf: コスト削減により$500/月の削減を達成
EOF
)"
# 出力：「perf: コスト削減により/月の削減を達成」（$500が変数として解釈され空文字列に置換）
```

**実行例**:
```bash
git commit -m "$(cat <<'EOF'
feat(auth): ユーザー認証機能を追加

Google OAuth 2.0を使用した認証機能を追加した。
ユーザーはGoogleアカウントでログインできるようになる。

Refs: #123
EOF
)"
```
