# Conventional Commits仕様

Conventional Commits仕様は、コミットメッセージに軽量な規則を提供するものである。明示的なコミット履歴を作成するための簡単なルールセットを提供し、その上に自動化ツールを構築しやすくする。この規約は、コミットメッセージで行われた機能、修正、破壊的変更を記述することにより、セマンティックバージョニング（SemVer）と合致する。

**用語の定義**: このドキュメントでは、以下の用語を使用します。詳細は [SKILL.md](../SKILL.md) を参照してください。
- **開発者**: このスキルを使用してコミットメッセージを生成する人（AIが対話する相手）
- **ユーザー**: ソフトウェアのエンドユーザー（開発者が作成するアプリケーションを使用する人）

## セマンティックバージョニング(SemVer)との関係

Conventional Commitsは、セマンティックバージョニングと以下のように対応する：

- **MAJOR** (X.0.0): 破壊的変更 (`BREAKING CHANGE:` または `!`)
- **MINOR** (0.X.0): 新機能の追加 (`feat`)
- **PATCH** (0.0.X): バグ修正 (`fix`)

その他のタイプ(`docs`, `chore`, `refactor`, `test`等)はバージョン番号に影響しない。

**注**: 0.x.xバージョン（初期開発段階）では、破壊的変更があってもMINORバージョンで対応する慣習がある。
この場合でも、`BREAKING CHANGE:`の記載は依然として重要である（変更履歴の明確化とツールによる検出のため）。

自動化ツール（例：semantic-release、standard-version）は、コミット履歴を解析してバージョン番号を自動的に決定する。そのため、正確なタイプ選択が重要である。

## 仕様

この仕様では、「MUST」「MUST NOT」「REQUIRED」「SHALL」「SHALL NOT」「SHOULD」「SHOULD NOT」「RECOMMENDED」「MAY」「OPTIONAL」というキーワードは、RFC 2119（要求レベルを示すキーワードの定義）に記載されているとおりに解釈される。

**主要なキーワードの意味**：
- **MUST / REQUIRED**: 必須（絶対に従わなければならない）
- **MUST NOT**: 禁止（絶対に行ってはならない）
- **SHOULD / RECOMMENDED**: 推奨（特別な理由がない限り従うべき）
- **SHOULD NOT**: 非推奨（特別な理由がない限り避けるべき）
- **MAY / OPTIONAL**: 任意（実装者の判断に委ねられる）

**AI向け注記**: このスキルでは、以下のキーワードが特に重要です：
- **MUST / REQUIRED**: タイプ、説明文、BREAKING CHANGEの形式など、必ず守るべきルール
- **SHOULD**: スコープの使用、本文の記述など、推奨される慣習
- これらを正確に守ることで、自動化ツール（semantic-release等）が正しく動作します

## コミットメッセージの構造

コミットメッセージは以下のように構造化される：

```text
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

## 仕様の詳細

### 必須事項（MUST / MUST NOT / REQUIRED）

1. **[必須] タイプの接頭辞**: コミットはタイプ（type）の接頭辞を付けなければならない。タイプは名詞で構成され、`feat`、`fix`などに続いてオプションのスコープ、オプションの`!`、そしてコロン(`:`)とスペースが続く。

2. **[必須] featタイプ**: タイプ`feat`は、コードベースに新しい機能を追加するコミットの際に使用しなければならない。（セマンティックバージョニングの`MINOR`に対応）

3. **[必須] fixタイプ**: タイプ`fix`は、コードベースのバグを修正するコミットの際に使用しなければならない。（セマンティックバージョニングの`PATCH`に対応）

4. **[必須] 説明文**: 説明文は、タイプ/スコープの接頭辞の後のコロンとスペースの直後に記述しなければならない。説明文は、コード変更の短い要約である。
   - 注：このスキルでは日本語で記述する（多言語プロジェクトでも、開発者が日本語を使用している場合は日本語を推奨）
   - 公式仕様の例: `fix: array parsing issue when multiple spaces were contained in string`

5. **[必須] 本文の配置**: 本文を記述する場合は、説明文の1行下から始めなければならない。

6. **[必須] フッターの構成**: 各フッターは、トークン、続いて`:<space>`または`<space>#`のいずれかの区切り文字、続いて文字列値で構成しなければならない。（[git trailer convention](https://git-scm.com/docs/git-interpret-trailers)に触発されている）

7. **[必須] フッターのトークン**: フッターのトークンは、空白文字の代わりに`-`を使用しなければならない。ただし、`BREAKING CHANGE`は例外である。

8. **[必須] 破壊的変更の表示**: 破壊的変更(Breaking changes)は、コミットのタイプ/スコープの接頭辞、または本文やフッターのエントリとして示さなければならない。

9. **[必須] 破壊的変更のフッター形式**: 破壊的変更をフッターに含める場合、大文字のテキスト`BREAKING CHANGE`で構成され、その後にコロン、スペース、および説明文が続かなければならない。
   例: `BREAKING CHANGE: environment variables now take precedence over config files`

10. **[必須] 破壊的変更の!記号**: 破壊的変更をタイプ/スコープの接頭辞に含める場合、`:`の直前に`!`で示さなければならない。

11. **[必須] 大文字小文字の扱い**: タイプ（`feat`, `fix`など）やトークン（`Refs`, `Closes`など）は、大文字小文字を区別せずに扱うべきである（例：`feat`と`Feat`は同じタイプとして扱う）。ただし、`BREAKING CHANGE`は常に大文字でなければならない。

12. **[必須] BREAKING-CHANGE**: `BREAKING-CHANGE`（ハイフン）は`BREAKING CHANGE`（スペース）と同義

### 任意事項（MAY / SHOULD）

1. **[任意] スコープ**: スコープはタイプの後に提供してもよい。スコープは、コードベースのセクションを記述する名詞で、括弧で囲まれている必要がある。
   例: `fix(parser):`

2. **[任意] 本文**: より長いコミット本文は、短い説明文の後に提供してもよく、コード変更に関する追加のコンテキスト情報を提供する。

3. **[任意] 本文の形式**: コミット本文は自由形式で、改行で区切られた任意の数の段落で構成してもよい。

4. **[任意] フッター**: 1つ以上のフッターは、本文の1行下に提供してもよい。

5. **[任意] フッターの値**: フッターの値には、空白と改行を含めることができる。

6. **[任意] その他のタイプ**: `feat`と`fix`以外のタイプは、コミットメッセージで使用してもよい。
   例: `docs: update ref docs`

7. **[任意] BREAKING CHANGEの省略**: `!`が使用される場合、`BREAKING CHANGE:`はフッターセクションから省略してもよく、コミットの説明文は破壊的変更を記述するために使用されるべきである。

## よく使われるタイプ

公式仕様では`feat`と`fix`のみが必須であるが、以下のタイプが一般的に使用される。

**注**: 複数のタイプに該当する場合や判断に迷う場合は [type-selection-guide.md](type-selection-guide.md) を参照すること。

- **feat**: 新機能の追加（セマンティックバージョニングの`MINOR`に対応）
    - 使用例: 新しいAPIエンドポイントの追加、新しいUIコンポーネントの実装、新しいユーザー機能の追加
- **fix**: バグ修正（セマンティックバージョニングの`PATCH`に対応）
    - 使用例: クラッシュやエラーの修正、予期しない動作の修正、セキュリティ脆弱性の修正
- **docs**: ドキュメントのみの変更
    - 使用例: READMEの更新、コメントの追加・修正、APIドキュメントの更新、使用例の追加
- **style**: コードの意味に影響しない変更（空白、フォーマット、セミコロンなど）
    - 使用例: インデントの修正、Linterルールの適用、コードフォーマッターの実行、不要な空白の削除
- **refactor**: バグ修正や機能追加を伴わないコードの改善
    - 使用例: コードの構造改善、変数名の変更、関数の分割、重複コードの削減
- **perf**: パフォーマンス改善
    - 使用例: データベースクエリの最適化、アルゴリズムの改善、レンダリング速度の向上
- **test**: テストの追加や既存テストの修正
    - 使用例: ユニットテストの追加、E2Eテストの実装、既存テストのアップデート、テストカバレッジの向上
- **build**: ビルドシステムや外部依存関係に影響する変更
    - 使用例: webpack設定の変更、npmスクリプトの変更、ビルドパイプラインの修正
- **ci**: CI設定ファイルやスクリプトの変更
    - 使用例: GitHub Actions/GitLab CI設定の変更、テスト自動化の設定、デプロイパイプラインの修正
- **chore**: ビルドプロセスやツール、ライブラリの変更（コード本体に影響しない作業）
    - 使用例: 依存関係のアップデート、パッケージマネージャーの設定変更、開発ツールの更新
- **revert**: 以前のコミットを取り消す
    - 使用例: 問題を引き起こしたコミットを元に戻す、デプロイ後に発見されたバグの原因となったコミットの取り消し
