# タイプ選択の詳細なガイドライン

複数のタイプに該当する場合や判断に迷う場合は、以下のガイドラインに従うこと。

**用語の定義**: このドキュメントでは、以下の用語を使用します。詳細は [SKILL.md](../SKILL.md) を参照してください。
- **開発者**: このスキルを使用してコミットメッセージを生成する人（AIが対話する相手）
- **ユーザー**: ソフトウェアのエンドユーザー（開発者が作成するアプリケーションを使用する人）

**前提**: 各タイプの基本的な定義と使用例については、[conventional-commits-spec.md](conventional-commits-spec.md#よく使われるタイプ) を参照すること。

## ケース1：バグ修正とリファクタリングを同時に行った場合
- **優先**: `fix`
- **理由**: バグ修正はユーザーに直接影響するため、リファクタリングよりも優先される
- **例**: バグを修正する過程でコードを整理した → `fix: ユーザーサービスのnullポインタ例外を解決`

## ケース2：新機能追加とドキュメント更新を同時に行った場合
- **優先**: `feat`
- **理由**: 新機能の追加が主な変更内容であり、ドキュメントはそれに付随するもの
- **例**: 新機能を追加し、READMEも更新した → `feat: ユーザー認証機能を追加`

## ケース3：複数の独立した変更を含む場合
- **推奨**: コミットを分割する
- **詳細な判断基準と処理フロー**: [execution-phases.md - 複数の変更を含む場合の処理](execution-phases.md#9-複数の変更を含む場合の処理) を参照

## ケース4：テストコードのみの変更
- **判断基準**:
  - 既存の機能に対する新しいテストを追加 → `test`
  - バグを修正するためのテストケースを追加 → `test` または `fix`（バグ修正を含む場合）
    - 例1: テストのみ追加 → `test(auth): ログインエラーのテストケースを追加`
    - 例2: バグ修正+テスト → `fix(auth): ログインエラーを修正し、テストを追加`
  - テストのリファクタリング → `test`

## ケース5：ドキュメントのみの変更か判断に迷う場合
- **ドキュメントのみの変更** → `docs`（定義は [conventional-commits-spec.md - よく使われるタイプ](conventional-commits-spec.md#よく使われるタイプ) を参照）
- **コードとドキュメントの両方を変更** → コードの変更タイプを優先（例：`feat`, `fix`）

## ケース6：依存関係(dependencies)の更新
- **セキュリティ脆弱性の修正を含む** → `fix(deps): セキュリティ脆弱性修正のためパッケージを更新`
- **通常のアップデート** → `chore(deps): 依存パッケージを更新`
- **新しいライブラリの追加** → `build: 機能Xのため新しい依存関係を追加`

## ケース7：設定ファイルの変更
- **ビルド設定**（webpack, rollup等） → `build`
- **CI/CD設定**（GitHub Actions, GitLab CI等） → `ci`
- **エディタ設定、linter設定** → `chore`
- **環境変数の追加・変更** → `chore` または関連する機能のタイプ

## ケース8：破壊的変更(Breaking Changes)を含む場合
- **必須**: タイプに`!`を付けるか、フッターに`BREAKING CHANGE:`を記載
- **簡潔な例**:
  - `feat!: APIレスポンス形式を変更`
  - `refactor!: 非推奨メソッドを削除`
- **詳細**: [execution-phases.md - フッターの追加と破壊的変更](execution-phases.md#8-フッターfooterの追加と破壊的変更の表示) を参照

---

**注**: コミットメッセージの基本的な例については、[examples.md - 基本的なコミットメッセージ](examples.md#基本的なコミットメッセージ) を参照してください。
